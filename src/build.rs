use std::{io::Write, path::PathBuf};

fn write_header(file: &mut std::fs::File) -> Result<(), std::io::Error> {
    writeln!(
        file,
        "// This file was generated by build.rs.\n// Do not modify directly\n"
    )
}

fn create_year_mod(year_dir: &PathBuf) -> Result<Vec<(usize, usize)>, std::io::Error> {
    let mut year_mod_path = year_dir.clone();
    year_mod_path.push("mod.rs");
    let mut year_mod_file = std::fs::File::create(&year_mod_path).unwrap();
    write_header(&mut year_mod_file)?;

    let mut solutions = vec![];
    let mut tests: Vec<String> = vec![];

    for day in std::fs::read_dir(year_dir).unwrap() {
        let fname = day.unwrap().file_name();
        let fname = fname.to_str().unwrap();
        let fname = &fname[0..fname.find('.').unwrap()];
        if fname.starts_with("day") {
            let day = fname
                .chars()
                .filter(char::is_ascii_digit)
                .collect::<String>()
                .parse()
                .unwrap();

            let year = year_dir
                .file_name()
                .unwrap()
                .to_str()
                .unwrap()
                .chars()
                .filter(char::is_ascii_digit)
                .collect::<String>()
                .parse()
                .unwrap();

            writeln!(year_mod_file, "pub mod {};", fname)?;
            tests.push(create_test(year, day));
            solutions.push((year, day));
        };
    }

    writeln!(year_mod_file, "\n{}", tests.join("\n"))?;
    Ok(solutions)
}

pub fn create_test(year: usize, day: usize) -> String {
    format!(
        r#"
#[test]
fn d{day}_part1() {{
    let sol = crate::y{year}::day_{day}::get_solution();
    crate::tests::test_year_day({year}, {day}, 1, &sol);
}}

#[test]
fn d{day}_part2() {{
    let sol = crate::y{year}::day_{day}::get_solution();
    crate::tests::test_year_day({year}, {day}, 2, &sol);
}}
"#
    )
}

fn main() {
    let years = std::fs::read_dir("./src/").unwrap();
    let mut all_solutions = vec![];

    for year in years.flatten() {
        if year.metadata().unwrap().is_dir() {
            let year_path = year.path();
            if year_path
                .file_name()
                .unwrap()
                .to_str()
                .unwrap()
                .starts_with('y')
            {
                let mut year_solutions = create_year_mod(&year_path).unwrap();
                all_solutions.append(&mut year_solutions);
            }
        }
    }

    let mut include_file = std::fs::File::create("./src/_include.rs").unwrap();
    write_header(&mut include_file).unwrap();

    let mut contents = Vec::new();
    all_solutions.sort();
    for (year, day) in all_solutions {
        contents.push(format!("        ({year}, {day}) => Box::new(crate::y{year}::day_{day}::get_solution()),"));
    }
    writeln!(
        include_file,
        "pub fn get_solution(year: usize, day: usize) -> Box<dyn crate::IsCorrect> {{\n    match (year, day) {{"
    ).unwrap();
    writeln!(include_file, "{}", contents.join("\n")).unwrap();
    writeln!(
        include_file,
        "        (year, day) => panic!(\"No solution for {{year}}/{{day}}\"),\n    }}\n}}"
    ).unwrap();
}
